# Data Warehouse Modeling: The Star Schema

You are now moving from **Database Administration** (keeping the app running) to **Business Intelligence** (analyzing the data).

In a standard app (OLTP), we normalize data to avoid duplication. In a Data Warehouse (OLAP), we **denormalize** data into a **Star Schema** to make reading it fast and easy.

## 1. The Core Concept: Facts vs. Dimensions

The Star Schema separates your data into two types of tables:

### ðŸŒŸ The Fact Table (The Center)
*   **What it is**: Represents **events** or **measurements**.
*   **Content**: Mostly IDs (Foreign Keys) and Numbers.
*   **Size**: Huge (Millions/Billions of rows).
*   **Example**: `Fact_Attendance`, `Fact_ExamResults`, `Fact_TuitionPayments`.

### ðŸ”· The Dimension Tables (The Points)
*   **What it is**: Represents the **context** (Who, What, Where, When).
*   **Content**: Descriptive text.
*   **Size**: Small (Hundreds/Thousands of rows).
*   **Example**: `Dim_Student`, `Dim_Teacher`, `Dim_Subject`, `Dim_Date`.

---

## 2. Visualizing the Star

Here is how we would model Student Performance in a Data Warehouse.

```mermaid
erDiagram
    Fact_ExamResults {
        int ResultKey PK
        int StudentKey FK
        int TeacherKey FK
        int SubjectKey FK
        int DateKey FK
        int Score
        int MaxScore
    }

    Dim_Student {
        int StudentKey PK
        int OriginalStudentID
        string FullName
        string Gender
        string CurrentGradeLevel
        string Address
    }

    Dim_Teacher {
        int TeacherKey PK
        string FullName
        string Department
        string YearsExperience
    }

    Dim_Subject {
        int SubjectKey PK
        string SubjectName
        string Category
        int Credits
    }

    Dim_Date {
        int DateKey PK
        date FullDate
        int Year
        string Month
        string Semester
        boolean IsWeekend
    }

    Fact_ExamResults }o--|| Dim_Student : "who"
    Fact_ExamResults }o--|| Dim_Teacher : "graded by"
    Fact_ExamResults }o--|| Dim_Subject : "in subject"
    Fact_ExamResults }o--|| Dim_Date : "on day"
```

---

## 3. Why do we do this?

### Simplicity
Look at how easy the query becomes. You don't need to join 10 tables to find a student's address or the semester. It's all right there in the Dimension.

**Query**: "Show me the average score for 'Science' subjects in '2024'."

```sql
SELECT 
    d_sub.SubjectName,
    AVG(f.Score) as AverageScore
FROM Fact_ExamResults f
JOIN Dim_Subject d_sub ON f.SubjectKey = d_sub.SubjectKey
JOIN Dim_Date d_date   ON f.DateKey = d_date.DateKey
WHERE 
    d_sub.Category = 'Science' 
    AND d_date.Year = 2024
GROUP BY d_sub.SubjectName;
```

### Performance
*   **Numbers are fast**: The Fact table is mostly numbers (Foreign Keys and Scores). Computers process numbers much faster than text.
*   **Fewer Joins**: You only join one level deep (Center to Point). You never join a Dimension to another Dimension (that would be a "Snowflake" schema, which is slower).

---

## 4. Implementation Example

Here is how you would actually create this structure in SQL.

```sql
-- 1. Create the Dimension Tables first
CREATE TABLE Dim_Student (
    StudentKey INT PRIMARY KEY, -- Surrogate Key (Internal ID)
    StudentID_Operational INT,  -- The ID from the real app
    FullName VARCHAR(100),
    Gender VARCHAR(10),
    City VARCHAR(50)
);

CREATE TABLE Dim_Date (
    DateKey INT PRIMARY KEY, -- e.g., 20240128
    FullDate DATE,
    Year INT,
    Quarter INT,
    MonthName VARCHAR(20)
);

-- 2. Create the Fact Table
CREATE TABLE Fact_ExamResults (
    ResultID INT PRIMARY KEY,
    StudentKey INT, -- Link to Dim_Student
    DateKey INT,    -- Link to Dim_Date
    Score INT,      -- The Metric
    
    -- Foreign Key Constraints
    FOREIGN KEY (StudentKey) REFERENCES Dim_Student(StudentKey),
    FOREIGN KEY (DateKey) REFERENCES Dim_Date(DateKey)
);
```

## 5. Key Takeaways for your Students
1.  **Denormalization is Good**: In a warehouse, it's okay to repeat "New York" for every student living there in `Dim_Student`. It makes reading faster.
2.  **Surrogate Keys**: Notice `StudentKey`? We create a *new* ID for the warehouse. This protects us if the original system changes its IDs or reuses them.
3.  **The "One Join" Rule**: In a Star Schema, you should be able to answer any question by joining the Fact Table to the relevant Dimension Tables.
